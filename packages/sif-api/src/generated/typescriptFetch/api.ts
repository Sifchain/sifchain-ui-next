/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Sichain API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.5
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://data.sifchain.finance/beta".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface ExternalAsset
 */
export interface ExternalAsset {
  /**
   *
   * @type {string}
   * @memberof ExternalAsset
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof ExternalAsset
   */
  balance?: string;
}
/**
 *
 * @export
 * @interface GetAssetsResponse
 */
export interface GetAssetsResponse {
  /**
   *
   * @type {string}
   * @memberof GetAssetsResponse
   */
  symbol?: string;
  /**
   * Full name of cryptocurrency.
   * @type {string}
   * @memberof GetAssetsResponse
   */
  name?: string;
  /**
   * Identifies whether withdrawals are enabled or disabled.
   * @type {boolean}
   * @memberof GetAssetsResponse
   */
  canWithdraw?: boolean;
  /**
   * Identifies whether deposits are enabled or disabled.
   * @type {boolean}
   * @memberof GetAssetsResponse
   */
  canDeposit?: boolean;
}
/**
 *
 * @export
 * @interface GetCirculatingSupplyResponse
 */
export interface GetCirculatingSupplyResponse {
  /**
   *
   * @type {string}
   * @memberof GetCirculatingSupplyResponse
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof GetCirculatingSupplyResponse
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface GetDailyPriceResponse
 */
export interface GetDailyPriceResponse {
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  tickerid?: string;
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  baseCurrency?: string;
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  targetCurrency?: string;
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  lastPrice?: string;
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  baseVolume?: string;
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  targetVolume?: string;
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  bid?: string;
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  ask?: string;
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  high?: string;
  /**
   *
   * @type {string}
   * @memberof GetDailyPriceResponse
   */
  low?: string;
}
/**
 *
 * @export
 * @interface GetDelegatorResponse
 */
export interface GetDelegatorResponse {
  /**
   *
   * @type {string}
   * @memberof GetDelegatorResponse
   */
  validatorAddress?: string;
  /**
   *
   * @type {string}
   * @memberof GetDelegatorResponse
   */
  validatorName?: string;
  /**
   *
   * @type {string}
   * @memberof GetDelegatorResponse
   */
  delegationTotal?: string;
  /**
   *
   * @type {string}
   * @memberof GetDelegatorResponse
   */
  unclaimedRewards?: string;
  /**
   *
   * @type {boolean}
   * @memberof GetDelegatorResponse
   */
  isSlashed?: boolean;
  /**
   * Validator uptime percentage over last 30 days
   * @type {string}
   * @memberof GetDelegatorResponse
   */
  performance?: string;
}
/**
 *
 * @export
 */
export type GetDelegatorsResponse = Array<GetDelegatorsResponseInner>;
/**
 *
 * @export
 * @interface GetDelegatorsResponseInner
 */
export interface GetDelegatorsResponseInner {
  /**
   *
   * @type {string}
   * @memberof GetDelegatorsResponseInner
   */
  delegatorAddress?: string;
  /**
   *
   * @type {string}
   * @memberof GetDelegatorsResponseInner
   */
  delegationTotal?: string;
}
/**
 *
 * @export
 * @interface GetHistoricalPriceResponse
 */
export interface GetHistoricalPriceResponse {
  /**
   * Unix timestamp in milliseconds.
   * @type {number}
   * @memberof GetHistoricalPriceResponse
   */
  timestamp?: number;
  /**
   *
   * @type {string}
   * @memberof GetHistoricalPriceResponse
   */
  priceInRowan?: string;
  /**
   *
   * @type {string}
   * @memberof GetHistoricalPriceResponse
   */
  priceInUSDC?: string;
}
/**
 *
 * @export
 * @interface GetInactiveValidatorsResponse
 */
export interface GetInactiveValidatorsResponse {
  /**
   *
   * @type {string}
   * @memberof GetInactiveValidatorsResponse
   */
  inactiveValidator?: string;
}
/**
 *
 * @export
 * @interface GetLiquidityProviderResponse
 */
export interface GetLiquidityProviderResponse {
  /**
   *
   * @type {GetLiquidityProvidersResponse}
   * @memberof GetLiquidityProviderResponse
   */
  liquidityProvider?: GetLiquidityProvidersResponse;
  /**
   *
   * @type {ExternalAsset}
   * @memberof GetLiquidityProviderResponse
   */
  externalAsset?: ExternalAsset;
  /**
   *
   * @type {NativeAsset}
   * @memberof GetLiquidityProviderResponse
   */
  nativeAsset?: NativeAsset;
  /**
   *
   * @type {string}
   * @memberof GetLiquidityProviderResponse
   */
  height?: string;
}
/**
 *
 * @export
 * @interface GetLiquidityProvidersResponse
 */
export interface GetLiquidityProvidersResponse {
  /**
   *
   * @type {string}
   * @memberof GetLiquidityProvidersResponse
   */
  units?: string;
  /**
   *
   * @type {string}
   * @memberof GetLiquidityProvidersResponse
   */
  address?: string;
}
/**
 *
 * @export
 * @interface GetNetworkResponse
 */
export interface GetNetworkResponse {
  /**
   *
   * @type {string}
   * @memberof GetNetworkResponse
   */
  totalRowanStaked?: string;
  /**
   *
   * @type {string}
   * @memberof GetNetworkResponse
   */
  totalUSDStaked?: string;
  /**
   *
   * @type {string}
   * @memberof GetNetworkResponse
   */
  blockReward?: string;
  /**
   *
   * @type {string}
   * @memberof GetNetworkResponse
   */
  averageBlockTime?: string;
  /**
   *
   * @type {string}
   * @memberof GetNetworkResponse
   */
  averageFee?: string;
  /**
   *
   * @type {string}
   * @memberof GetNetworkResponse
   */
  totalUsers?: string;
  /**
   *
   * @type {string}
   * @memberof GetNetworkResponse
   */
  networkBondingTime?: string;
  /**
   *
   * @type {string}
   * @memberof GetNetworkResponse
   */
  validatorMinimumBondAmount?: string;
  /**
   *
   * @type {string}
   * @memberof GetNetworkResponse
   */
  delegatorMinimumBondAmount?: string;
}
/**
 *
 * @export
 * @interface GetPeggedAssetsResponse
 */
export interface GetPeggedAssetsResponse {
  /**
   *
   * @type {string}
   * @memberof GetPeggedAssetsResponse
   */
  tokenName?: string;
  /**
   *
   * @type {string}
   * @memberof GetPeggedAssetsResponse
   */
  value?: string;
}
/**
 *
 * @export
 * @interface GetPoolResponse
 */
export interface GetPoolResponse {
  /**
   *
   * @type {GetPoolsResponse}
   * @memberof GetPoolResponse
   */
  pool?: GetPoolsResponse;
  /**
   *
   * @type {string}
   * @memberof GetPoolResponse
   */
  clpModuleAddress?: string;
  /**
   *
   * @type {string}
   * @memberof GetPoolResponse
   */
  height?: string;
}
/**
 *
 * @export
 * @interface GetPoolsResponse
 */
export interface GetPoolsResponse {
  /**
   *
   * @type {ExternalAsset}
   * @memberof GetPoolsResponse
   */
  externalAsset?: ExternalAsset;
  /**
   *
   * @type {NativeAsset}
   * @memberof GetPoolsResponse
   */
  nativeAsset?: NativeAsset;
  /**
   *
   * @type {string}
   * @memberof GetPoolsResponse
   */
  poolUnits?: string;
}
/**
 *
 * @export
 * @interface GetSummaryResponse
 */
export interface GetSummaryResponse {
  /**
   * Identifier of a ticker with delimiter to separate base/quote, eg. BTC-USD (Price of BTC is quoted in USD)
   * @type {string}
   * @memberof GetSummaryResponse
   */
  tradingPairs?: string;
  /**
   * Symbol/currency code of base currency, eg. BTC
   * @type {string}
   * @memberof GetSummaryResponse
   */
  baseCurrency?: string;
  /**
   * Symbol/currency code of target currency, eg. USD
   * @type {string}
   * @memberof GetSummaryResponse
   */
  targetCurrency?: string;
  /**
   * Last transacted price of base currency based on given quote currency
   * @type {string}
   * @memberof GetSummaryResponse
   */
  lastPrice?: string;
  /**
   * 24-hr volume of market pair denoted in BASE currency
   * @type {string}
   * @memberof GetSummaryResponse
   */
  baseVolume?: string;
  /**
   * 24-hr volume of market pair denoted in Target currency
   * @type {string}
   * @memberof GetSummaryResponse
   */
  targetVolume?: string;
  /**
   * 24-hr % price change of market pair
   * @type {string}
   * @memberof GetSummaryResponse
   */
  priceChangePercent24H?: string;
  /**
   * Highest price of base currency based on given quote currency in the last 24-hrs
   * @type {string}
   * @memberof GetSummaryResponse
   */
  highestPrice24H?: string;
  /**
   * Lowest price of base currency based on given quote currency in the last 24-hrs
   * @type {string}
   * @memberof GetSummaryResponse
   */
  lowestPrice24H?: string;
  /**
   * Lowest Ask price of base currency based on given quote currency
   * @type {string}
   * @memberof GetSummaryResponse
   */
  lowestAsk?: string;
  /**
   * Highest bid price of base currency based on given quote currency
   * @type {string}
   * @memberof GetSummaryResponse
   */
  highestBid?: string;
}
/**
 *
 * @export
 * @interface GetTokenValueResponse
 */
export interface GetTokenValueResponse {
  /**
   *
   * @type {string}
   * @memberof GetTokenValueResponse
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof GetTokenValueResponse
   */
  priceInUSDC?: string;
  /**
   *
   * @type {string}
   * @memberof GetTokenValueResponse
   */
  priceInRowan?: string;
}
/**
 *
 * @export
 * @interface GetTotalStakedByDelegatorsResponse
 */
export interface GetTotalStakedByDelegatorsResponse {
  /**
   *
   * @type {string}
   * @memberof GetTotalStakedByDelegatorsResponse
   */
  amountDelegated?: string;
}
/**
 *
 * @export
 * @interface GetTotalSupplyResponse
 */
export interface GetTotalSupplyResponse {
  /**
   *
   * @type {string}
   * @memberof GetTotalSupplyResponse
   */
  denom?: string;
  /**
   *
   * @type {string}
   * @memberof GetTotalSupplyResponse
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface GetTradeResponse
 */
export interface GetTradeResponse {
  /**
   * A unique ID associated with the trade for the currency pair transaction
   * @type {string}
   * @memberof GetTradeResponse
   */
  tradeId?: string;
  /**
   * Last transacted price of base currency based on given quote currency. (same as baseVolume)
   * @type {string}
   * @memberof GetTradeResponse
   */
  price?: string;
  /**
   * Transaction amount in BASE currency.
   * @type {string}
   * @memberof GetTradeResponse
   */
  baseVolume?: string;
  /**
   * Transaction amount in TARGET currency.
   * @type {string}
   * @memberof GetTradeResponse
   */
  targetVolume?: string;
  /**
   * Symbol of base token.
   * @type {string}
   * @memberof GetTradeResponse
   */
  baseToken?: string;
  /**
   * Symbol of target token.
   * @type {string}
   * @memberof GetTradeResponse
   */
  targetToken?: string;
  /**
   * Unix timestamp in milliseconds for when the transaction occurred.
   * @type {number}
   * @memberof GetTradeResponse
   */
  timestamp?: number;
  /**
   * Type of trade. Sifcahin does not have Buy or Sell trades. We Swap.
   * @type {string}
   * @memberof GetTradeResponse
   */
  type?: string;
}
/**
 *
 * @export
 * @interface GetValidatorResponse
 */
export interface GetValidatorResponse {
  /**
   *
   * @type {string}
   * @memberof GetValidatorResponse
   */
  validatorAddress?: string;
  /**
   *
   * @type {string}
   * @memberof GetValidatorResponse
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof GetValidatorResponse
   */
  stakedAmount?: string;
  /**
   *
   * @type {string}
   * @memberof GetValidatorResponse
   */
  selfDelegation?: string;
  /**
   *
   * @type {string}
   * @memberof GetValidatorResponse
   */
  externalDelegation?: string;
  /**
   *
   * @type {string}
   * @memberof GetValidatorResponse
   */
  unclaimedRewards?: string;
  /**
   *
   * @type {boolean}
   * @memberof GetValidatorResponse
   */
  isSlashed?: boolean;
  /**
   *
   * @type {string}
   * @memberof GetValidatorResponse
   */
  balance?: string;
  /**
   * Validator uptime percentage over last 30 days
   * @type {string}
   * @memberof GetValidatorResponse
   */
  performance?: string;
}
/**
 *
 * @export
 */
export type GetValidatorsResponse = Array<any>;
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   * The staking rewards rate.
   * @type {string}
   * @memberof InlineResponse200
   */
  rate?: string;
}
/**
 *
 * @export
 * @interface NativeAsset
 */
export interface NativeAsset {
  /**
   *
   * @type {string}
   * @memberof NativeAsset
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof NativeAsset
   */
  balance?: string;
}
/**
 *
 * @export
 * @interface PoolShareResponse
 */
export interface PoolShareResponse {
  /**
   *
   * @type {string}
   * @memberof PoolShareResponse
   */
  poolShare?: string;
}
/**
 * AssetsApi - fetch parameter creator
 * @export
 */
export const AssetsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This end point gets the statistics of tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenStats(options: any = {}): FetchArgs {
      const localVarPath = `/asset/tokenStats`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This end point gets the statistics of tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenStats(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<GetCirculatingSupplyResponse> {
      const localVarFetchArgs =
        AssetsApiFetchParamCreator(configuration).getTokenStats(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * This end point gets the statistics of tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenStats(options?: any) {
      return AssetsApiFp(configuration).getTokenStats(options)(fetch, basePath);
    },
  };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
  /**
   * This end point gets the statistics of tokens
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getTokenStats(options?: any) {
    return AssetsApiFp(this.configuration).getTokenStats(options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * NetworkApi - fetch parameter creator
 * @export
 */
export const NetworkApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cmcTotalDailyVolume(options: any = {}): FetchArgs {
      const localVarPath = `/cmcTotalDailyVolume`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The summary endpoint is to provide an overview of market data for all tickers and all market pairs on the exchange.
     * @summary Get an overview of market data for all tickers and all markets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCmcSummary(options: any = {}): FetchArgs {
      const localVarPath = `/cmcsummary`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDailyPrice(options: any = {}): FetchArgs {
      const localVarPath = `/dailyPrice`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This end point gets daily OHLC ticker data.
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistoricalPrice(symbol: string, options: any = {}): FetchArgs {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError(
          "symbol",
          "Required parameter symbol was null or undefined when calling getHistoricalPrice.",
        );
      }
      const localVarPath = `/historicalPrice/{symbol}`.replace(
        `{${"symbol"}}`,
        encodeURIComponent(String(symbol)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetworkInfo(options: any = {}): FetchArgs {
      const localVarPath = `/network`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The summary endpoint is to provide an overview of market data for all tickers and all market pairs on the exchange.
     * @summary Get an overview of market data for all tickers and all markets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSummary(options: any = {}): FetchArgs {
      const localVarPath = `/summary`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * NetworkApi - functional programming interface
 * @export
 */
export const NetworkApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cmcTotalDailyVolume(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        NetworkApiFetchParamCreator(configuration).cmcTotalDailyVolume(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * The summary endpoint is to provide an overview of market data for all tickers and all market pairs on the exchange.
     * @summary Get an overview of market data for all tickers and all markets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCmcSummary(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<GetSummaryResponse>> {
      const localVarFetchArgs =
        NetworkApiFetchParamCreator(configuration).getCmcSummary(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDailyPrice(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<GetDailyPriceResponse>> {
      const localVarFetchArgs =
        NetworkApiFetchParamCreator(configuration).getDailyPrice(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This end point gets daily OHLC ticker data.
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistoricalPrice(
      symbol: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<GetHistoricalPriceResponse>> {
      const localVarFetchArgs = NetworkApiFetchParamCreator(
        configuration,
      ).getHistoricalPrice(symbol, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetworkInfo(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetNetworkResponse> {
      const localVarFetchArgs =
        NetworkApiFetchParamCreator(configuration).getNetworkInfo(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * The summary endpoint is to provide an overview of market data for all tickers and all market pairs on the exchange.
     * @summary Get an overview of market data for all tickers and all markets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSummary(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<GetSummaryResponse>> {
      const localVarFetchArgs =
        NetworkApiFetchParamCreator(configuration).getSummary(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * NetworkApi - factory interface
 * @export
 */
export const NetworkApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cmcTotalDailyVolume(options?: any) {
      return NetworkApiFp(configuration).cmcTotalDailyVolume(options)(
        fetch,
        basePath,
      );
    },
    /**
     * The summary endpoint is to provide an overview of market data for all tickers and all market pairs on the exchange.
     * @summary Get an overview of market data for all tickers and all markets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCmcSummary(options?: any) {
      return NetworkApiFp(configuration).getCmcSummary(options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDailyPrice(options?: any) {
      return NetworkApiFp(configuration).getDailyPrice(options)(
        fetch,
        basePath,
      );
    },
    /**
     * This end point gets daily OHLC ticker data.
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistoricalPrice(symbol: string, options?: any) {
      return NetworkApiFp(configuration).getHistoricalPrice(symbol, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetworkInfo(options?: any) {
      return NetworkApiFp(configuration).getNetworkInfo(options)(
        fetch,
        basePath,
      );
    },
    /**
     * The summary endpoint is to provide an overview of market data for all tickers and all market pairs on the exchange.
     * @summary Get an overview of market data for all tickers and all markets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSummary(options?: any) {
      return NetworkApiFp(configuration).getSummary(options)(fetch, basePath);
    },
  };
};

/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
export class NetworkApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NetworkApi
   */
  public cmcTotalDailyVolume(options?: any) {
    return NetworkApiFp(this.configuration).cmcTotalDailyVolume(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * The summary endpoint is to provide an overview of market data for all tickers and all market pairs on the exchange.
   * @summary Get an overview of market data for all tickers and all markets.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NetworkApi
   */
  public getCmcSummary(options?: any) {
    return NetworkApiFp(this.configuration).getCmcSummary(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NetworkApi
   */
  public getDailyPrice(options?: any) {
    return NetworkApiFp(this.configuration).getDailyPrice(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * This end point gets daily OHLC ticker data.
   * @param {string} symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NetworkApi
   */
  public getHistoricalPrice(symbol: string, options?: any) {
    return NetworkApiFp(this.configuration).getHistoricalPrice(symbol, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NetworkApi
   */
  public getNetworkInfo(options?: any) {
    return NetworkApiFp(this.configuration).getNetworkInfo(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * The summary endpoint is to provide an overview of market data for all tickers and all market pairs on the exchange.
   * @summary Get an overview of market data for all tickers and all markets.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NetworkApi
   */
  public getSummary(options?: any) {
    return NetworkApiFp(this.configuration).getSummary(options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * PoolsApi - fetch parameter creator
 * @export
 */
export const PoolsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} symbol
     * @param {string} lpAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiquidityProvider(
      symbol: string,
      lpAddress: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError(
          "symbol",
          "Required parameter symbol was null or undefined when calling getLiquidityProvider.",
        );
      }
      // verify required parameter 'lpAddress' is not null or undefined
      if (lpAddress === null || lpAddress === undefined) {
        throw new RequiredError(
          "lpAddress",
          "Required parameter lpAddress was null or undefined when calling getLiquidityProvider.",
        );
      }
      const localVarPath = `/pool/{symbol}/liquidityProvider/{lpAddress}`
        .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)))
        .replace(`{${"lpAddress"}}`, encodeURIComponent(String(lpAddress)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiquidityProviders(symbol: string, options: any = {}): FetchArgs {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError(
          "symbol",
          "Required parameter symbol was null or undefined when calling getLiquidityProviders.",
        );
      }
      const localVarPath = `/pool/{symbol}/liquidityProvider`.replace(
        `{${"symbol"}}`,
        encodeURIComponent(String(symbol)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPool(symbol: string, options: any = {}): FetchArgs {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError(
          "symbol",
          "Required parameter symbol was null or undefined when calling getPool.",
        );
      }
      const localVarPath = `/pool/{symbol}`.replace(
        `{${"symbol"}}`,
        encodeURIComponent(String(symbol)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} symbol
     * @param {string} lpAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolShare(
      symbol: string,
      lpAddress: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'symbol' is not null or undefined
      if (symbol === null || symbol === undefined) {
        throw new RequiredError(
          "symbol",
          "Required parameter symbol was null or undefined when calling getPoolShare.",
        );
      }
      // verify required parameter 'lpAddress' is not null or undefined
      if (lpAddress === null || lpAddress === undefined) {
        throw new RequiredError(
          "lpAddress",
          "Required parameter lpAddress was null or undefined when calling getPoolShare.",
        );
      }
      const localVarPath = `/pool/{symbol}/liquidityProvider/{lpAddress}/share`
        .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)))
        .replace(`{${"lpAddress"}}`, encodeURIComponent(String(lpAddress)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPools(options: any = {}): FetchArgs {
      const localVarPath = `/pool`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PoolsApi - functional programming interface
 * @export
 */
export const PoolsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} symbol
     * @param {string} lpAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiquidityProvider(
      symbol: string,
      lpAddress: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<GetLiquidityProviderResponse> {
      const localVarFetchArgs = PoolsApiFetchParamCreator(
        configuration,
      ).getLiquidityProvider(symbol, lpAddress, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiquidityProviders(
      symbol: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<GetLiquidityProvidersResponse>> {
      const localVarFetchArgs = PoolsApiFetchParamCreator(
        configuration,
      ).getLiquidityProviders(symbol, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPool(
      symbol: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetPoolResponse> {
      const localVarFetchArgs = PoolsApiFetchParamCreator(
        configuration,
      ).getPool(symbol, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} symbol
     * @param {string} lpAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolShare(
      symbol: string,
      lpAddress: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PoolShareResponse> {
      const localVarFetchArgs = PoolsApiFetchParamCreator(
        configuration,
      ).getPoolShare(symbol, lpAddress, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPools(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<GetPoolsResponse>> {
      const localVarFetchArgs =
        PoolsApiFetchParamCreator(configuration).getPools(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * PoolsApi - factory interface
 * @export
 */
export const PoolsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @param {string} symbol
     * @param {string} lpAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiquidityProvider(symbol: string, lpAddress: string, options?: any) {
      return PoolsApiFp(configuration).getLiquidityProvider(
        symbol,
        lpAddress,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLiquidityProviders(symbol: string, options?: any) {
      return PoolsApiFp(configuration).getLiquidityProviders(symbol, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {string} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPool(symbol: string, options?: any) {
      return PoolsApiFp(configuration).getPool(symbol, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {string} symbol
     * @param {string} lpAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolShare(symbol: string, lpAddress: string, options?: any) {
      return PoolsApiFp(configuration).getPoolShare(
        symbol,
        lpAddress,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPools(options?: any) {
      return PoolsApiFp(configuration).getPools(options)(fetch, basePath);
    },
  };
};

/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
export class PoolsApi extends BaseAPI {
  /**
   *
   * @param {string} symbol
   * @param {string} lpAddress
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolsApi
   */
  public getLiquidityProvider(
    symbol: string,
    lpAddress: string,
    options?: any,
  ) {
    return PoolsApiFp(this.configuration).getLiquidityProvider(
      symbol,
      lpAddress,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolsApi
   */
  public getLiquidityProviders(symbol: string, options?: any) {
    return PoolsApiFp(this.configuration).getLiquidityProviders(
      symbol,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolsApi
   */
  public getPool(symbol: string, options?: any) {
    return PoolsApiFp(this.configuration).getPool(symbol, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {string} symbol
   * @param {string} lpAddress
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolsApi
   */
  public getPoolShare(symbol: string, lpAddress: string, options?: any) {
    return PoolsApiFp(this.configuration).getPoolShare(
      symbol,
      lpAddress,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolsApi
   */
  public getPools(options?: any) {
    return PoolsApiFp(this.configuration).getPools(options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * StatsApi - fetch parameter creator
 * @export
 */
export const StatsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This end point gets the total circulating supply of Rowan as a string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cmcCirculatingSupply(options: any = {}): FetchArgs {
      const localVarPath = `/asset/cmcCirculatingSupply`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cmcTotalSupply(options: any = {}): FetchArgs {
      const localVarPath = `/asset/cmcTotalSupply`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This end point gets the total circulating supply of Rowan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCirculatingSupply(options: any = {}): FetchArgs {
      const localVarPath = `/asset/circulatingsupply`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStakingRewards(options: any = {}): FetchArgs {
      const localVarPath = `/validator/stakingRewards`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalSupply(options: any = {}): FetchArgs {
      const localVarPath = `/asset/totalSupply`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This end point gets the total circulating supply of Rowan as a string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cmcCirculatingSupply(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        StatsApiFetchParamCreator(configuration).cmcCirculatingSupply(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cmcTotalSupply(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        StatsApiFetchParamCreator(configuration).cmcTotalSupply(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This end point gets the total circulating supply of Rowan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCirculatingSupply(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<GetCirculatingSupplyResponse> {
      const localVarFetchArgs =
        StatsApiFetchParamCreator(configuration).getCirculatingSupply(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStakingRewards(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs =
        StatsApiFetchParamCreator(configuration).getStakingRewards(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalSupply(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<GetTotalSupplyResponse> {
      const localVarFetchArgs =
        StatsApiFetchParamCreator(configuration).getTotalSupply(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * This end point gets the total circulating supply of Rowan as a string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cmcCirculatingSupply(options?: any) {
      return StatsApiFp(configuration).cmcCirculatingSupply(options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cmcTotalSupply(options?: any) {
      return StatsApiFp(configuration).cmcTotalSupply(options)(fetch, basePath);
    },
    /**
     * This end point gets the total circulating supply of Rowan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCirculatingSupply(options?: any) {
      return StatsApiFp(configuration).getCirculatingSupply(options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStakingRewards(options?: any) {
      return StatsApiFp(configuration).getStakingRewards(options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalSupply(options?: any) {
      return StatsApiFp(configuration).getTotalSupply(options)(fetch, basePath);
    },
  };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
  /**
   * This end point gets the total circulating supply of Rowan as a string.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatsApi
   */
  public cmcCirculatingSupply(options?: any) {
    return StatsApiFp(this.configuration).cmcCirculatingSupply(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatsApi
   */
  public cmcTotalSupply(options?: any) {
    return StatsApiFp(this.configuration).cmcTotalSupply(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * This end point gets the total circulating supply of Rowan.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatsApi
   */
  public getCirculatingSupply(options?: any) {
    return StatsApiFp(this.configuration).getCirculatingSupply(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatsApi
   */
  public getStakingRewards(options?: any) {
    return StatsApiFp(this.configuration).getStakingRewards(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatsApi
   */
  public getTotalSupply(options?: any) {
    return StatsApiFp(this.configuration).getTotalSupply(options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * TradesApi - fetch parameter creator
 * @export
 */
export const TradesApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * The trades endpoint is to return data on all recently completed trades for a given market pair.
     * @summary Get recently completed trades for a given market (24 hours)
     * @param {string} marketPair A pair such as “eth_usdt”. Must be seperated by an underscore and in the format {base}_{target}.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrades(marketPair: string, options: any = {}): FetchArgs {
      // verify required parameter 'marketPair' is not null or undefined
      if (marketPair === null || marketPair === undefined) {
        throw new RequiredError(
          "marketPair",
          "Required parameter marketPair was null or undefined when calling getTrades.",
        );
      }
      const localVarPath = `/trade/{market_pair}`.replace(
        `{${"market_pair"}}`,
        encodeURIComponent(String(marketPair)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TradesApi - functional programming interface
 * @export
 */
export const TradesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * The trades endpoint is to return data on all recently completed trades for a given market pair.
     * @summary Get recently completed trades for a given market (24 hours)
     * @param {string} marketPair A pair such as “eth_usdt”. Must be seperated by an underscore and in the format {base}_{target}.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrades(
      marketPair: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<GetTradeResponse>> {
      const localVarFetchArgs = TradesApiFetchParamCreator(
        configuration,
      ).getTrades(marketPair, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TradesApi - factory interface
 * @export
 */
export const TradesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * The trades endpoint is to return data on all recently completed trades for a given market pair.
     * @summary Get recently completed trades for a given market (24 hours)
     * @param {string} marketPair A pair such as “eth_usdt”. Must be seperated by an underscore and in the format {base}_{target}.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrades(marketPair: string, options?: any) {
      return TradesApiFp(configuration).getTrades(marketPair, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
export class TradesApi extends BaseAPI {
  /**
   * The trades endpoint is to return data on all recently completed trades for a given market pair.
   * @summary Get recently completed trades for a given market (24 hours)
   * @param {string} marketPair A pair such as “eth_usdt”. Must be seperated by an underscore and in the format {base}_{target}.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradesApi
   */
  public getTrades(marketPair: string, options?: any) {
    return TradesApiFp(this.configuration).getTrades(marketPair, options)(
      this.fetch,
      this.basePath,
    );
  }
}
/**
 * ValidatorsApi - fetch parameter creator
 * @export
 */
export const ValidatorsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} delegatorAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelegator(delegatorAddress: string, options: any = {}): FetchArgs {
      // verify required parameter 'delegatorAddress' is not null or undefined
      if (delegatorAddress === null || delegatorAddress === undefined) {
        throw new RequiredError(
          "delegatorAddress",
          "Required parameter delegatorAddress was null or undefined when calling getDelegator.",
        );
      }
      const localVarPath = `/validator/delegator/{delegatorAddress}`.replace(
        `{${"delegatorAddress"}}`,
        encodeURIComponent(String(delegatorAddress)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} validatorAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelegators(validatorAddress: string, options: any = {}): FetchArgs {
      // verify required parameter 'validatorAddress' is not null or undefined
      if (validatorAddress === null || validatorAddress === undefined) {
        throw new RequiredError(
          "validatorAddress",
          "Required parameter validatorAddress was null or undefined when calling getDelegators.",
        );
      }
      const localVarPath = `/validator/{validatorAddress}/delegator`.replace(
        `{${"validatorAddress"}}`,
        encodeURIComponent(String(validatorAddress)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInactiveValidators(options: any = {}): FetchArgs {
      const localVarPath = `/validator/inactiveValidators`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalStakedByDelegators(options: any = {}): FetchArgs {
      const localVarPath = `/validator/delegator/totalStaked`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} validatorAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidator(validatorAddress: string, options: any = {}): FetchArgs {
      // verify required parameter 'validatorAddress' is not null or undefined
      if (validatorAddress === null || validatorAddress === undefined) {
        throw new RequiredError(
          "validatorAddress",
          "Required parameter validatorAddress was null or undefined when calling getValidator.",
        );
      }
      const localVarPath = `/validator/{validatorAddress}`.replace(
        `{${"validatorAddress"}}`,
        encodeURIComponent(String(validatorAddress)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidators(options: any = {}): FetchArgs {
      const localVarPath = `/validator`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ValidatorsApi - functional programming interface
 * @export
 */
export const ValidatorsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} delegatorAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelegator(
      delegatorAddress: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetDelegatorResponse> {
      const localVarFetchArgs = ValidatorsApiFetchParamCreator(
        configuration,
      ).getDelegator(delegatorAddress, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} validatorAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelegators(
      validatorAddress: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetDelegatorsResponse> {
      const localVarFetchArgs = ValidatorsApiFetchParamCreator(
        configuration,
      ).getDelegators(validatorAddress, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInactiveValidators(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<GetInactiveValidatorsResponse>> {
      const localVarFetchArgs =
        ValidatorsApiFetchParamCreator(configuration).getInactiveValidators(
          options,
        );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalStakedByDelegators(
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<GetTotalStakedByDelegatorsResponse> {
      const localVarFetchArgs =
        ValidatorsApiFetchParamCreator(
          configuration,
        ).getTotalStakedByDelegators(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} validatorAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidator(
      validatorAddress: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetValidatorResponse> {
      const localVarFetchArgs = ValidatorsApiFetchParamCreator(
        configuration,
      ).getValidator(validatorAddress, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidators(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetValidatorsResponse> {
      const localVarFetchArgs =
        ValidatorsApiFetchParamCreator(configuration).getValidators(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ValidatorsApi - factory interface
 * @export
 */
export const ValidatorsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @param {string} delegatorAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelegator(delegatorAddress: string, options?: any) {
      return ValidatorsApiFp(configuration).getDelegator(
        delegatorAddress,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @param {string} validatorAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDelegators(validatorAddress: string, options?: any) {
      return ValidatorsApiFp(configuration).getDelegators(
        validatorAddress,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInactiveValidators(options?: any) {
      return ValidatorsApiFp(configuration).getInactiveValidators(options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalStakedByDelegators(options?: any) {
      return ValidatorsApiFp(configuration).getTotalStakedByDelegators(options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {string} validatorAddress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidator(validatorAddress: string, options?: any) {
      return ValidatorsApiFp(configuration).getValidator(
        validatorAddress,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidators(options?: any) {
      return ValidatorsApiFp(configuration).getValidators(options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * ValidatorsApi - object-oriented interface
 * @export
 * @class ValidatorsApi
 * @extends {BaseAPI}
 */
export class ValidatorsApi extends BaseAPI {
  /**
   *
   * @param {string} delegatorAddress
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorsApi
   */
  public getDelegator(delegatorAddress: string, options?: any) {
    return ValidatorsApiFp(this.configuration).getDelegator(
      delegatorAddress,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} validatorAddress
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorsApi
   */
  public getDelegators(validatorAddress: string, options?: any) {
    return ValidatorsApiFp(this.configuration).getDelegators(
      validatorAddress,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorsApi
   */
  public getInactiveValidators(options?: any) {
    return ValidatorsApiFp(this.configuration).getInactiveValidators(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorsApi
   */
  public getTotalStakedByDelegators(options?: any) {
    return ValidatorsApiFp(this.configuration).getTotalStakedByDelegators(
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} validatorAddress
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorsApi
   */
  public getValidator(validatorAddress: string, options?: any) {
    return ValidatorsApiFp(this.configuration).getValidator(
      validatorAddress,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ValidatorsApi
   */
  public getValidators(options?: any) {
    return ValidatorsApiFp(this.configuration).getValidators(options)(
      this.fetch,
      this.basePath,
    );
  }
}
